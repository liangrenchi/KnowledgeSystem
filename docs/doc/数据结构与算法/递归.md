## 什么是递归

递归是一个过程或函数直接或间接调用自身的一种方法，它可以把一个大型的问题层层转化为一个原问题相似、但规模较小的问题求解。**递归实质上也是一种循环结构**，它把“较复杂”情况的计算归结为“较简单”情况的计算，一直归结到“最简单”情况的计算为止。**递归在概念上简化了问题，而不是因为它提高效率。**

## 递归调用的实现原理

在数值计算领域可以采用递归计算，在非数值领域递归的应用也非常广泛。可以说，**递归就是程序设计中的数学归纳法**。

### 递归算法的构成

应用递归应满足以下三个条件：

1. 需要解决的问题可以转化成一个或多个子问题来求解，并且这些子问题的求解方法与原来的问题完全相同，只是数量规模上不同
2. 递归调用的次数必须是有限的
3. 必须有结束递归的条件（边界条件）来终止递归

一般递归算法的设计分成两步：

1. 将规模较大的原问题分解为一个或多个规模较小的而又类似于原问题特性的子问题，即将较大的问题递归地用较小的子问题来描述，解决原问题的方法同样可以用来解决子问题。（**递归的步骤**）
2. 确定一个或多个不需要分解、可直接求解的最小子问题。（**最小子问题是递归的终结条件**）

【例1】计算n!的递归方法

```java
public static int fact(int n){
        int temp;
        if (n==0){ //递归终止的条件
            return 1;
        }else {
            temp = n*fact1(n-1); //递归调用
        }
        return temp;
}
```

递归的方法只需少量的程序代码就可描述出解题过程所需要的多次重复计算，大大的减少程序的代码量。递归的能力就在于用有限的语句来定义对象的无限集合。

### 递归调用的内部过程

递归函数的调用类似于多层函数的嵌套调用，只是调用单位和被调用单位是同一个函数而已。对于【例1】中求阶层的问题，假设程序运行时，n=4，则程序的执行过程如下图所示：

![image-20230603173709248](https://menuimg.oss-cn-beijing.aliyuncs.com/image-20230603173709248.png)

递归调用的过程分成两个阶段：

1. `递归过程`：将原始问题不断转化为规模小了一级的新问题，从求4！变成求3！变成求2！，最终达到递归的终止条件，求1！
2. `回溯过程`：从已知条件出发，沿递归的逆过程，逐一求值返回，直到递归初始处，完成递归调用

在这两个阶段中，系统会分别完成一系列的操作。在递归调用之前，系统需完成三项工作（**使用栈完成操作**）：

1. 为被调用过程的局部变量分配存储区
2. 将所有的实参、返回地址等信息传递给被调用过程保存
3. 将控制转移到被调过程的入口

从被调用过程返回调用过程之前，系统也应完成三项工作：

1. 保存被调过程的计算结果
2. 释放被过程的数据区
3. 依照被调过程保存的返回地址将控制转移到调用过程

### 递归的正确性证明

可采用数学归纳法证明递归的正确性。

例如【例1】对于求阶层的递归函数fact(n)，可用归纳法证明如下：

【证明】当n=0,fact(n)=1

假设对于正整数n，fact(n)=n!，试证明fact(n+1)=(n+1)!

fact(n+1)

=(n+1)*fact((n+1)-1)

=(n+1)*fact(n)

=(n+1)*n!

=(n+1)!

在以上归纳证明中，是对程序所操作的变量（正整数）进行归纳。然而，许多程序并没有明确可归纳的整数，因此在大多时候，需要对程序的递归结构进行归纳，这也是结构归纳法和一般数学归纳法的区别所在。

## 递归转化为非递归

有些递归问题可以转化为非递归的方法实现，如伪递归可以用递推的方法实现。有些递归问题可以用回溯法解决。

### 递归转化为递推

当递归算法涉及的数据定义形式是递归的情况下，通常可以将递归算法转化为递推算法，用递归的边界条件作为递推的边界条件，比如求阶层、斐波那契数列等。

递推也是一种从已知条件出发，用一种具体的算法，一步一步接近未知，一般釆用循环结构，经常和枚举配合使用。递推算法在求解的过程中，每一个中间变量都是已知的，而且没有重复计算，运算简捷，但是书写代码和理解代码比较难。

【例2】求阶乘的递推算法

```java
public static int fact2(int n){
        int s=1;
        for (int i=1;i<=n;i++){
            s=s*i;
        }
        return s;
}
```

【例3】斐波那契数列的递推算法

```java
public static int fact3(int n){
        int f0=1,f1=1,f = 0;
        if (n<2) return 1;
        for (int i=3;i<=n;i++){
            f = f0+f1;
            f0=f1;
            f1=f;
        }
        return f;
}
```

递归是从未知到已知，再从已知返回未知，利用子问题与父问题的关系，进而构造成有递归性的函数。

递推则与此相反，是从已知到未知，类似于一般解数学题的思路。

递归把问题简单化，抓的是问题与子问题的联系，而递推是从中间解推进，抓的是中间量与更靠近未知的中间量的联系，所以不能看成是互逆问题。

### 递归转化为回溯	

对于可以用回溯算法解决的问题，也可以用非递归的回溯来实现，如“八皇后问题”

回溯方法的步骤如下：

1. 定义一个解空间，它包含问题的解
2. 用适于搜索的方式组织该空间
3. 用深度优先法搜索该空间，利用限界函数避免移动到不可能产生解的子空间

回溯算法的一个有趣的特性是在搜索执行的同时产生解空间。在搜索期间的任何时刻，仅保留从开始结点到当前节点的路径。因此，回溯算法的空间需求为O（从开始结点起最长路径的长度）。这个特性非常重要，因为解空间的大小通常是最长路径长度的指数或阶乘，所以如果要存储全部解空间的话，再多的空间也不够用。

【例4】回溯法求八皇后问题

实现思路：

- 我们先在棋盘的第0行第1个棋格放下第一个皇后
- 下一行寻找一个不冲突的棋格放下下一个皇后
- 循环第2步
- 如果到某一行全部8个格子都无法放下皇后，回溯到前一行，继续寻找下一个不冲突的棋格
- 把8个皇后都放在棋盘之后，输出或存储摆法，结束

**定义棋盘**

我们通过一个二维整型数组表示一个棋盘，数组内为1是放下了的皇后，0则是空白的棋格

我们下下面定义一个方法：通过检查棋格是否为1来知道是不是有皇后

```java
// 定义一个棋盘
static int chessboard[][] = new int[8][8];
```

**检查冲突**

这个方法用来检查冲突：在水平垂直方向、斜角上的棋格有无其他皇后，传入的（x,y）是需要检查的棋格，如检查棋格（1,0）即棋盘的第2行第1个，是否能放下皇后。

```java
// 检查是否符合规则
private static boolean checked(int x,int y){
        for(int i = 0;i<y;i++){
            // 检查水平垂直方向
            if(chessboard[x][i]==1)return false;
            // 检测左斜角
            if((x-y+i>=0)&&chessboard[x-y+i][i]==1)return false;
            // 检查右斜角
            if((x+y-i<=7)&&chessboard[x+y-i][i]==1)return false;
        }
        return true;
}
```

**放下皇后**

我们在每一行都执行以下步骤，通过从第1个棋格到第8个遍历寻找可以放下皇后的棋格，如果放下了皇后，我们就可以继续放下下一个了，将行数+1，我们递归调用这个方法

```java
public static boolean solve(int y){
        // 将一行的8种情况都扫描一次
        for(int i = 0;i<8;i++){
            // 每次检测前都将当前行清空,避免脏数据
            for(int k = 0;k<8;k++)chessboard[k][y]=0;
            if(checked(i, y)){
                chessboard[i][y] = 1;
                // 当前一行已经获得解法,进入下一行
                solve(y+1);
            }
        }
        return false;
}
```

**算法边界**

当我们放下了所有8个皇后后，需要一个终止条件，我们在行数y=8时，结束算法

```java
// 当y=8时,已经找到一种解决方法
if(y == 8){
   return true;
}
```

**完整代码**

```java
public class EightQueen{
    // 定义一个棋盘
    static int chessboard[][] = new int[8][8];
    // 计数器
    static int count = 0;

    // 解题方法
    public static boolean solve(int y){
        // 当y=8时,已经找到一种解决方法,计数器加一并输入摆法
        if(y == 8){
            System.out.println("solved!");
            show();
            count++;
            return true;
        }
        // 将一行的8种情况都扫描一次
        for(int i = 0;i<8;i++){
            // 每次检测前都将当前行清空,避免脏数据
            for(int k = 0;k<8;k++)chessboard[k][y]=0;
            if(checked(i, y)){
                chessboard[i][y] = 1;
                // 当前一行已经获得解法,进入下一行
                solve(y+1);
            }
        }
        return false;
    }
    // 检查是否符合规则
    private static boolean checked(int x,int y){
        for(int i = 0;i<y;i++){
            // 检查垂直方向
            if(chessboard[x][i]==1)return false;
            // 检测左斜角
            if((x-y+i>=0)&&chessboard[x-y+i][i]==1)return false;
            // 检查右斜角
            if((x+y-i<=7)&&chessboard[x+y-i][i]==1)return false;
        }
        return true;
    }
    // 输出棋盘摆法
    public static void show(){
        for(int i = 0;i<8;i++){
            for(int j = 0;j<8;j++){
                System.out.print(chessboard[j][i]+"  ");
            }
            System.out.println("");
        }
    }
}
```

